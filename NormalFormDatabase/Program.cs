// See https://aka.ms/new-console-template for more information
Console.WriteLine("Hello, World!");

/*

    Перша нормальна форма (1NF) допомагає вирішити деякі загальні проблеми, які можуть виникнути у базах даних. 
Ось основні з них:

1. **Недопустимі повторювані групи**: (Атомарність кожної одиниці)
    
    Таблиці повинні містити лише атомарні (неподільні) значення, а не списки або множини значень в одному полі.

        Давайте розглянемо приклад, щоб зрозуміти, що означають "недопустимі повторювані групи" на практиці.

        Припустимо, у нас є таблиця Orders, яка зберігає інформацію про замовлення і продукти, включені до них:

        OrderID	    CustomerName    Products
        1	        Ivanov	        Apple, Banana
        2	        Petrov	        Orange, Apple, Grape
        3	        Sidorov	        Banana
        
        У цьому прикладі колонка Products містить повторювані групи значень (списки продуктів). 
        Це порушує першу нормальну форму (1NF), оскільки значення в колонці мають бути атомарними (неподільними).

        Щоб привести таблицю до 1NF, ми повинні розділити повторювані групи на окремі рядки:

        OrderID     CustomerName	Product
        1	        Ivanov	        Apple
        1	        Ivanov	        Banana
        2	        Petrov	        Orange
        2	        Petrov	        Apple
        2	        Petrov	        Grape
        3	        Sidorov	        Banana
        
        Тепер кожен рядок містить атомарне значення у колонці Product, що відповідає вимогам першої нормальної форми (1NF).

2. **Непослідовні дані**: (Одноманітність даних)
    
    Запобігається зберігання неструктурованих або неоднорідних даних в одній колонці.
    
    Непослідовні дані виникають, коли в одній колонці зберігаються дані різних типів або форм. 
    Це може призвести до проблем з обробкою та аналізом даних. Давайте розглянемо приклад.

    Припустимо, у нас є таблиця Contacts, яка містить інформацію про контакти:

    ContactID	Name	    Phone
    1	        Ivanov	    (123) 456-7890
    2	        Petrov	    987-654-3210
    3	        Sidorov	    +1-800-555-1234
    4	        Kovalenko	Not Available
    
    У цьому прикладі колонка Phone містить дані у різних форматах, 
    включаючи різні формати телефонних номерів і навіть текстове значення "Not Available". 
    Це порушує консистентність даних і ускладнює їх обробку.

    Щоб вирішити цю проблему та привести таблицю до першої нормальної форми (1NF), 
    потрібно забезпечити однорідність даних у колонці Phone. 
    Наприклад, можна використовувати один стандартизований формат для телефонних номерів:

    ContactID	Name	    Phone
    1	        Ivanov	    123-456-7890
    2	        Petrov	    987-654-3210
    3	        Sidorov	    800-555-1234
    4	        Kovalenko	NULL
    
    Тепер колонка Phone містить телефонні номери в одному форматі, 
    а значення "Not Available" замінено на NULL, що більш підходить для відсутніх даних. 
    Це забезпечує узгодженість даних і спрощує їх обробку.

    Це приклад, як забезпечення 1NF допомагає уникати непослідовних даних у базах даних, 
    забезпечуючи їх однорідність та зручність використання.
    

3. **Змішування різних видів даних**: (Одноманітність даних до кожного стовпчика)
        Не допускається змішування різних видів даних в одному стовпчику, що сприяє чіткості та прозорості 
    структури даних.

    ItemID	Description	    Details
    1	    Apple	        50 kg
    2	    Office Chair	Blue, Adjustable
    3	    Laptop	        15-inch, i7 processor
    4	    Orange	        30 kg

4. **Проблеми з доступом та аналізом даних**: (Кількість ускладнює, атомарність до кожного спрощує) 
    Спрощується доступ і аналіз даних, оскільки кожне значення в полі є унікальним і неподільним.

        Проблеми з доступом та аналізом даних можуть виникати, 
        коли дані в базі даних неструктуровані або не відповідають першій нормальній формі (1NF). 
        Давайте розглянемо приклад.

        Припустимо, у нас є таблиця Employees, яка містить інформацію про співробітників і їхні телефонні номери:

        EmployeeID	Name	PhoneNumbers
        1	        Ivanov	123-456-7890, 987-654-3210
        2	        Petrov	555-555-5555
        3	        Sidorov	111-222-3333, 444-555-6666, 777-888-9999
        У цій таблиці колонка PhoneNumbers містить списки телефонних номерів, 
        розділених комами. Це порушує 1NF, оскільки кожне значення в колонці має бути атомарним (неподільним). 
        Такі дані ускладнюють доступ і аналіз, оскільки важко, наприклад, знайти всіх співробітників 
        з певним номером телефону або зробити фільтрацію за номером телефону.

        Щоб привести таблицю до 1NF і уникнути проблем з доступом та аналізом даних, 
        потрібно розділити телефонні номери на окремі рядки:

        EmployeeID	Name	PhoneNumber
        1	        Ivanov	123-456-7890
        1	        Ivanov	987-654-3210
        2	        Petrov	555-555-5555
        3	        Sidorov	111-222-3333
        3	        Sidorov	444-555-6666
        3	        Sidorov	777-888-9999
        Тепер кожен рядок містить атомарне значення у колонці PhoneNumber, що відповідає вимогам 1NF. 
        Це значно спрощує доступ і аналіз даних, оскільки можна легко виконувати пошук 
        і фільтрацію за телефонним номером. Наприклад, можна знайти всіх співробітників 
        з номером телефону 555-555-5555 або зробити вибірку всіх номерів телефону для певного співробітника.

        Таким чином, застосування 1NF допомагає уникати проблем з доступом та аналізом даних, 
        забезпечуючи структурування даних у таблиці у зручний та логічний спосіб.


5. **Утруднення пошуку та фільтрації**: (Одна колонка, одна атомарна одиниця)
    Пошук та фільтрація стають простішими, оскільки дані зберігаються в уніфікованій структурі.

            Утруднення пошуку та фільтрації виникає, коли дані в базі даних структуровані так, 
            що їх важко ефективно знайти або відфільтрувати. Давайте розглянемо приклад, щоб зрозуміти це краще.

            Припустимо, у нас є таблиця Products, яка містить інформацію про товари:

            ProductID	ProductName	    Details
            1	        Laptop	        Dell, i7, 16GB RAM, 512GB SSD
            2	        Smartphone	    Samsung, 128GB, Black
            3	        Office Chair	Ergonomic, Adjustable, Black
            4	        Laptop	        HP, i5, 8GB RAM, 256GB SSD

                У цій таблиці колонка Details містить змішані дані різних атрибутів товарів. 
            Це ускладнює пошук і фільтрацію, оскільки всі характеристики зберігаються в одному полі. 
            Наприклад, якщо потрібно знайти всі товари певного бренду або з певними характеристиками, 
            це стане проблематичним.

                Щоб вирішити цю проблему, потрібно розділити змішані дані на окремі колонки, 
            забезпечуючи однорідність даних у кожній колонці. Наприклад:

            ProductID	ProductName	    Brand	    Processor	RAM	    Storage	Color	Type
            1	        Laptop	        Dell	    i7	        16GB	512GB	NULL	NULL
            2	        Smartphone	    Samsung	    NULL	    NULL	128GB	Black	NULL
            3	        Office Chair	NULL	    NULL	    NULL	NULL	Black	Ergonomic
            4	        Laptop	        HP	        i5	        8GB	    256GB	NULL	NULL

                Тепер кожен атрибут товару зберігається в окремій колонці, що дозволяє легко виконувати пошук 
            і фільтрацію. Наприклад, можна знайти всі товари певного бренду (наприклад, Dell) або 
            з певною кількістю оперативної пам'яті (16GB RAM).

    Таким чином, застосування першої нормальної форми (1NF) допомагає уникати утруднень 
з пошуком та фільтрацією даних, забезпечуючи чітку та однорідну структуру даних у таблиці.


Друга нормальна форма (2NF) допомагає вирішити деякі проблеми, пов'язані з частковими залежностями
в базах даних. Ось основні з них:

Часткові залежності: Усі неключові атрибути повинні повністю залежати від первинного ключа, а не лише 
від частини первинного ключа.

        Часткові залежності виникають тоді, коли неключовий атрибут залежить лише від частини первинного ключа, 
    а не від усього ключа в таблиці з композитним (складовим) ключем. Давайте розглянемо приклад, щоб це краще 
    зрозуміти.

    Припустимо, у нас є таблиця Orders, яка містить інформацію про замовлення і товари:

    OrderID	ProductID	ProductName	Quantity
    1	    1001	    Apple	    10
    1	    1002	    Banana	    5
    2	    1001	    Apple	    15
    2	    1003	    Orange	    7
    
        У цій таблиці OrderID та ProductID разом складають композитний первинний ключ, що ідентифікує кожен рядок. 
    Однак атрибут ProductName залежить лише від ProductID, а не від усього композитного ключа (OrderID, ProductID). 
    Це є частковою залежністю.

        Щоб усунути часткові залежності та привести таблицю до другої нормальної форми (2NF), 
    ми повинні розділити таблицю на дві окремі таблиці:

    Таблиця Orders, що містить інформацію про замовлення:

    OrderID	    ProductID	Quantity
    1	        1001	    10
    1	        1002	    5
    2	        1001	    15
    2	        1003	    7
    
    Таблиця Products, що містить інформацію про товари:

    ProductID	ProductName
    1001	    Apple
    1002	    Banana
    1003	    Orange
    
        Тепер атрибут ProductName зберігається у відокремленій таблиці Products, 
    де він залежить лише від ProductID, який є первинним ключем у цій таблиці. 
    Це усуває часткові залежності і забезпечує відповідність другої нормальної форми (2NF).

Надлишкові дані: Уникнення дублювання даних, що може зберігатися в різних рядках таблиці.

        Надлишкові дані виникають, коли однакова інформація зберігається в 
    декількох рядках таблиці, що призводить до дублювання. Це неефективно і може ускладнити 
    підтримку даних. Давайте розглянемо приклад.

        Припустимо, у нас є таблиця Enrollments, яка містить інформацію про студентів і курси:

    StudentID   StudentName	    CourseID    CourseName
    1	        Ivanov	        101	        Math
    1	        Ivanov	        102	        Physics
    2	        Petrov	        101	        Math
    2	        Petrov	        103	        Chemistry
        
        У цьому прикладі атрибути StudentName і CourseName дублюються в різних рядках таблиці. 
    Це створює надлишковість даних.

        Щоб усунути надлишкові дані та привести таблицю до другої нормальної форми (2NF), 
    ми можемо розділити її на дві окремі таблиці:

        Таблиця Students, що містить інформацію про студентів:

    StudentID	StudentName
    1	        Ivanov
    2	        Petrov
        
        Таблиця Courses, що містить інформацію про курси:

    CourseID	CourseName
    101	        Math
    102	        Physics
    103	        Chemistry
    
        Таблиця Enrollments, що зберігає зв'язок між студентами і курсами:

    StudentID	CourseID
    1	        101
    1	        102
    2	        101
    2	        103
    
        Тепер у таблиці Enrollments зберігаються лише ключові дані (StudentID і CourseID), 
    а вся інша інформація зберігається в окремих таблицях Students і Courses. 
    Це усуває дублювання даних і забезпечує відповідність другої нормальної форми (2NF).

Аномалії вставки: Зменшення ризику виникнення аномалій при додаванні нових даних до таблиці.

        Аномалії вставки виникають, коли існує необхідність додати новий запис до таблиці, 
    але через структуру таблиці це стає проблематичним або неможливим без введення надлишкових 
    або неповних даних. Давайте розглянемо приклад.

        Припустимо, у нас є таблиця StudentCourses, яка містить інформацію про студентів і курси, 
    на які вони записані:

    StudentID	StudentName	    CourseID	CourseName
    1	        Ivanov	        101	        Math
    2	        Petrov	        102	        Physics

        Якщо ми хочемо додати нового студента, який поки що не записаний на жоден курс, 
    ми можемо зіткнутися з аномалією вставки. Наприклад, для додавання студента з ім'ям "Sidorov" 
    нам потрібно вказати значення для CourseID і CourseName, навіть якщо цей студент 
    ще не записаний на жоден курс. Це призводить до введення недійсних або неповних даних.

        Щоб уникнути аномалій вставки та привести таблицю до другої нормальної форми (2NF), 
    ми можемо розділити таблицю на дві окремі таблиці:

        Таблиця Students, що містить інформацію про студентів:

    StudentID	StudentName
    1	        Ivanov
    2	        Petrov
    3	        Sidorov
    
        Таблиця Enrollments, що зберігає зв'язок між студентами і курсами:

    StudentID	CourseID
    1	        101
    2	        102
        
        Таблиця Courses, що містить інформацію про курси:

    CourseID	CourseName
    101	        Math
    102	        Physics
        
        Тепер ми можемо додати нового студента до таблиці Students, навіть якщо він поки що 
    не записаний на жоден курс. Це дозволяє уникнути аномалій вставки та забезпечує відповідність 
    другої нормальної форми (2NF).

Аномалії оновлення: Зниження ризику виникнення помилок або невідповідностей при оновленні даних.

        Аномалії оновлення виникають, коли одні й ті самі дані зберігаються у кількох місцях, 
    і при оновленні одного з них можуть виникнути помилки або невідповідності. 
    Давайте розглянемо приклад.

        Припустимо, у нас є таблиця Students, яка містить інформацію про студентів і курси:

    StudentID	StudentName	CourseID	CourseName
    1	        Ivanov	    101	        Math
    2	        Petrov	    102	        Physics
    3	        Ivanov	    103	        Chemistry
        
        У цьому прикладі ім'я студента Ivanov дублюється для різних курсів. 
    Якщо ім'я студента змінюється (наприклад, на Ivanov Jr.), потрібно оновити всі рядки, 
    де це ім'я зустрічається. Якщо помилково оновити тільки один із рядків, виникнуть невідповідності:

    StudentID	StudentName	CourseID	CourseName
    1	        Ivanov Jr.	101	        Math
    2	        Petrov	    102	        Physics
    3	        Ivanov	    103	        Chemistry
        Щоб уникнути аномалій оновлення та привести таблицю до другої нормальної форми (2NF), 
    потрібно розділити таблицю на дві окремі таблиці:

        Таблиця Students, що містить інформацію про студентів:

    StudentID	StudentName
    1	        Ivanov Jr.
    2	        Petrov
        
        Таблиця Enrollments, що зберігає зв'язок між студентами і курсами:

    StudentID	CourseID
    1	        101
    1	        103
    2	        102
        
        Таблиця Courses, що містить інформацію про курси:

    CourseID	CourseName
    101	        Math
    102	        Physics
    103	        Chemistry
    
        Тепер, якщо потрібно оновити ім'я студента Ivanov на Ivanov Jr., 
    це можна зробити лише в одному місці - у таблиці Students. Це зменшує ризик 
    виникнення помилок або невідповідностей і забезпечує відповідність другої нормальної форми (2NF).

Аномалії видалення: Зменшення ймовірності втрати корисної інформації при видаленні даних з таблиці.

        Аномалії видалення виникають тоді, коли видалення одного запису призводить до 
    небажаної втрати іншої важливої інформації. Давайте розглянемо приклад.

        Припустимо, у нас є таблиця ProjectAssignments, яка містить інформацію про проєкти 
    та співробітників, що працюють над ними:

    ProjectID	ProjectName	    EmployeeID	EmployeeName
    1	        Project A	    101	        Ivanov
    2	        Project B	    102	        Petrov
    1	        Project A	    103	        Sidorov

        У цьому прикладі кожен рядок містить інформацію про проєкт і співробітника. 
    Припустимо, ми хочемо видалити всі записи про Project A. Це призведе до видалення всіх рядків, 
    пов'язаних з цим проєктом, включаючи імена співробітників Ivanov і Sidorov. 
    У результаті ми втратимо інформацію про цих співробітників, навіть якщо вони можуть бути    
    важливими для інших записів.

        Щоб уникнути аномалій видалення та привести таблицю до другої нормальної форми (2NF), 
    ми можемо розділити таблицю на дві окремі таблиці:

        Таблиця Projects, що містить інформацію про проєкти:

    ProjectID	ProjectName
    1	        Project A
    2	        Project B
        
        Таблиця Employees, що містить інформацію про співробітників:

    EmployeeID	EmployeeName
    101	        Ivanov
    102	        Petrov
    103	        Sidorov
        
        Таблиця ProjectAssignments, що зберігає зв'язок між проєктами і співробітниками:

    ProjectID	EmployeeID
    1	        101
    2	        102
    1	        103
        
        Тепер, якщо ми хочемо видалити всі записи про Project A, ми можемо зробити це, 
    не втрачаючи інформацію про співробітників Ivanov і Sidorov. Це зменшує ймовірність втрати 
    корисної інформації та забезпечує відповідність другої нормальної форми (2NF).


Третя нормальна форма (3NF) допомагає вирішити деякі проблеми, 
пов'язані з транзитивними залежностями в базах даних. Ось основні з них:

        Транзитивні залежності: Усі неключові атрибути повинні безпосередньо залежати від первинного ключа, 
    а не через інші неключові атрибути.

            Транзитивні залежності виникають тоді, коли неключовий атрибут залежить від первинного ключа 
        через інший неключовий атрибут, а не безпосередньо. Давайте розглянемо приклад.

            Припустимо, у нас є таблиця Employees, яка містить інформацію про співробітників і їхні відділи:

            EmployeeID	EmployeeName	DepartmentID	DepartmentName
            1	        Ivanov	        101	            Sales
            2	        Petrov	        102	            Marketing
            3	        Sidorov	        101	            Sales
            
            У цьому прикладі EmployeeID є первинним ключем таблиці. Але атрибут DepartmentName 
        залежить не безпосередньо від EmployeeID, а через DepartmentID. Це є транзитивною залежністю.

            Щоб усунути транзитивні залежності та привести таблицю до третьої нормальної форми (3NF), 
        ми повинні розділити таблицю на дві окремі таблиці:

            Таблиця Employees, що містить інформацію про співробітників:

            EmployeeID	EmployeeName	DepartmentID
            1	        Ivanov	        101
            2	        Petrov	        102
            3	        Sidorov	        101
            
            Таблиця Departments, що містить інформацію про відділи:

            DepartmentID	DepartmentName
            101	            Sales
            102	            Marketing
            
            Тепер кожен неключовий атрибут залежить безпосередньо від первинного ключа своєї таблиці. 
            Атрибут DepartmentName залежить від DepartmentID, який є первинним ключем таблиці Departments.

        Надлишкові дані: Зменшення дублювання даних, що може зберігатися в різних рядках таблиці.

                Надлишкові дані виникають, коли однакова інформація зберігається у кількох місцях, 
            що призводить до дублювання. Це неефективно і може ускладнити підтримку даних. 
            Давайте розглянемо приклад.

                Припустимо, у нас є таблиця StudentsCourses, яка містить інформацію про студентів 
            і курси, на які вони записані:

            StudentID	StudentName	    CourseID	CourseName
            1	        Ivanov	        101	        Math
            1	        Ivanov	        102	        Physics
            2	        Petrov	        101	        Math
            2	        Petrov	        103	        Chemistry
                
                У цьому прикладі атрибути StudentName і CourseName дублюються в різних рядках таблиці. 
            Це створює надлишковість даних.

                Щоб усунути надлишкові дані та привести таблицю до третьої нормальної форми (3NF), 
            ми можемо розділити її на дві окремі таблиці:

                Таблиця Students, що містить інформацію про студентів:

                StudentID	StudentName
                1	        Ivanov
                2	        Petrov
                
                Таблиця Courses, що містить інформацію про курси:

                CourseID	CourseName
                101	        Math
                102	        Physics
                103	        Chemistry
                
                Таблиця Enrollments, що зберігає зв'язок між студентами і курсами:

                StudentID	CourseID
                1	        101
                1	        102
                2	        101
                2	        103
                
                Тепер у таблиці Enrollments зберігаються лише ключові дані (StudentID і CourseID), 
            а вся інша інформація зберігається в окремих таблицях Students і Courses. 
            Це усуває дублювання даних і забезпечує відповідність третьої нормальної форми (3NF).
        
        Аномалії вставки: Уникнення проблем, які можуть виникати при додаванні нових даних до таблиці.

                Аномалії вставки виникають тоді, коли структура таблиці створює проблеми 
            при додаванні нових записів. Давайте розглянемо приклад.

                Припустимо, у нас є таблиця StudentsCourses, яка містить інформацію про студентів і курси:

                StudentID	StudentName	    CourseID	CourseName	    ProfessorName
                1	        Ivanov	        101	        Math	        Dr. Smith
                1	        Ivanov	        102	        Physics	        Dr. Johnson
                2	        Petrov	        103	        Chemistry	    Dr. Lee
                
                Якщо ми хочемо додати нового професора, який ще не викладає жодного курсу, 
            ми можемо зіткнутися з аномалією вставки. Наприклад, якщо ми хочемо додати професора Dr. Brown, 
            нам потрібно вказати значення для StudentID, StudentName, CourseID і CourseName, 
            навіть якщо цей професор ще не викладає жодного курсу. Це призводить до введення недійсних 
            або неповних даних.

                Щоб уникнути аномалій вставки та привести таблицю до третьої нормальної форми (3NF), 
            ми можемо розділити її на три окремі таблиці:

                Таблиця Students, що містить інформацію про студентів:

            StudentID	StudentName
            1	        Ivanov
            2	        Petrov
            
                Таблиця Courses, що містить інформацію про курси:

            CourseID	CourseName	ProfessorID
            101	        Math	    1
            102	        Physics	    2
            103	        Chemistry	3
            
                Таблиця Professors, що містить інформацію про професорів:

            ProfessorID	    ProfessorName
            1	            Dr. Smith
            2	            Dr. Johnson
            3	            Dr. Lee
            4	            Dr. Brown
            
                Таблиця Enrollments, що зберігає зв'язок між студентами і курсами:

            StudentID	CourseID
            1	        101
            1	        102
            2	        103
            
                Тепер ми можемо додати нового професора до таблиці Professors, навіть якщо він ще 
            не викладає жодного курсу. Це дозволяє уникнути аномалій вставки та забезпечує відповідність 
            третьої нормальної форми (3NF).

                Таким чином, застосування 3NF допомагає уникати аномалій вставки, забезпечуючи зручне 
            та надійне додавання нових даних до бази даних.


        Аномалії оновлення: Зменшення ризику виникнення помилок або невідповідностей при оновленні даних.

                Аномалії оновлення виникають тоді, коли одні й ті самі дані зберігаються у кількох місцях, 
            і при оновленні одного з них можуть виникнути помилки або невідповідності. Давайте розглянемо приклад.

                Припустимо, у нас є таблиця StudentsCourses, яка містить інформацію про студентів і курси, 
            на які вони записані, а також інформацію про викладачів:

                StudentID	StudentName	    CourseID	CourseName	    ProfessorName
                1	        Ivanov	        101	        Math	        Dr. Smith
                2	        Petrov	        102	        Physics	        Dr. Johnson
                3	        Sidorov	        101	        Math	        Dr. Smith
                
                У цьому прикладі атрибут ProfessorName дублюється для кожного курсу, на якому він викладає. 
            Якщо ім'я професора змінюється (наприклад, Dr. Smith змінює ім'я на Dr. Brown), потрібно 
            оновити всі рядки, де це ім'я зустрічається. Якщо помилково оновити тільки один із рядків, 
            виникнуть невідповідності:

                StudentID	StudentName	    CourseID	CourseName	ProfessorName
                1	        Ivanov	        101	        Math	    Dr. Brown
                2	        Petrov	        102	        Physics	    Dr. Johnson
                3	        Sidorov	        101	        Math	    Dr. Smith
                
                Щоб уникнути аномалій оновлення та привести таблицю до третьої нормальної форми (3NF), 
            потрібно розділити таблицю на три окремі таблиці:

                Таблиця Students, що містить інформацію про студентів:

                StudentID	StudentName
                1	        Ivanov
                2	        Petrov
                3	        Sidorov
                
                Таблиця Courses, що містить інформацію про курси:

                CourseID	CourseName      ProfessorID
                101	        Math	        1
                102	        Physics	        2
                
                Таблиця Professors, що містить інформацію про викладачів:

                ProfessorID	    ProfessorName
                1	            Dr. Smith
                2	            Dr. Johnson
                
                Таблиця Enrollments, що зберігає зв'язок між студентами і курсами:

                StudentID	CourseID
                1	        101
                2	        102
                3	        101
                    Тепер, якщо потрібно оновити ім'я професора Dr. Smith на Dr. Brown, 
                це можна зробити лише в одному місці - у таблиці Professors. 
                Це зменшує ризик виникнення помилок або невідповідностей і забезпечує відповідність 
                третьої нормальної форми (3NF).


        Аномалії видалення: Зменшення ймовірності втрати корисної інформації при видаленні даних з таблиці.
            
                Аномалії видалення виникають тоді, коли видалення одного запису призводить до небажаної втрати 
            іншої важливої інформації. Давайте розглянемо приклад.

                Припустимо, у нас є таблиця CourseEnrollments, яка містить інформацію про курси, 
            студентів і викладачів:

                CourseID	CourseName	StudentID	StudentName	ProfessorName
                101	        Math	    1	        Ivanov	    Dr. Smith
                102	        Physics	    2	        Petrov	    Dr. Johnson
                101	        Math	    3	        Sidorov	    Dr. Smith
 
                У цьому прикладі, якщо ми хочемо видалити запис про курс Math (CourseID 101), 
            ми також видалимо інформацію про студента Ivanov та Sidorov і професора Dr. Smith. 
            Це призводить до втрати важливої інформації про студентів та викладача, навіть якщо 
            ці дані можуть бути корисними для інших курсів.

                Щоб уникнути аномалій видалення та привести таблицю до третьої нормальної форми (3NF), 
            потрібно розділити таблицю на кілька окремих таблиць:

                Таблиця Courses, що містить інформацію про курси:

                CourseID	CourseName
                101	        Math
                102	        Physics
                
                Таблиця Students, що містить інформацію про студентів:

                StudentID	StudentName
                1	        Ivanov
                2	        Petrov
                3	        Sidorov
                
                Таблиця Professors, що містить інформацію про викладачів:

                ProfessorName
                Dr. Smith
                Dr. Johnson

                Таблиця CourseEnrollments, що зберігає зв'язок між курсами і студентами:

                CourseID	StudentID
                101	        1
                102	        2
                101	        3
                
                Таблиця CourseProfessors, що зберігає зв'язок між курсами і викладачами:

                CourseID	ProfessorName
                101	        Dr. Smith
                102	        Dr. Johnson

                    Тепер, якщо ми хочемо видалити курс Math (CourseID 101), ми можемо це зробити, 
                не втрачаючи інформацію про студентів Ivanov та Sidorov, а також професора Dr. Smith. 
                Це зменшує ймовірність втрати корисної інформації та забезпечує відповідність 
                третьої нормальної форми (3NF).

                Проблеми з підтримкою цілісності: Покращення підтримки цілісності даних, забезпечуючи 
            коректні зв'язки між даними.

                Ці загальні проблеми часто виникають при роботі з базами даних, і застосування 3NF допомагає 
            їх уникнути, забезпечуючи більш ефективне та надійне управління даними.

    Нормальна форма Бойса-Кодда (BCNF) є спеціальним випадком третьої нормальної форми (3NF) 
і допомагає вирішити деякі додаткові проблеми, пов'язані з функціональними залежностями в базах даних. 
Ось основні з них:

    Аномалії вставки: Зниження ймовірності виникнення проблем при додаванні нових даних до таблиці.
        
            Аномалії вставки виникають тоді, коли структура таблиці створює проблеми при додаванні нових записів. 
        Давайте розглянемо приклад на основі нормальної форми Бойса-Кодда (BCNF).

        Припустимо, у нас є таблиця `RoomAssignments`, яка містить інформацію про приміщення, викладачів і предмети:

        | RoomNumber | ProfessorName | Subject     |
        |------------|---------------|-------------|
        | 101        | Dr. Smith     | Mathematics |
        | 102        | Dr. Johnson   | Physics     |
        | 101        | Dr. Lee       | Chemistry   |

        У цьому прикладі, якщо ми хочемо додати новий предмет, який ще не викладається в жодному приміщенні, ми можемо зіткнутися з аномалією вставки. Наприклад, для додавання предмету `Biology`, нам потрібно вказати значення для `RoomNumber` та `ProfessorName`, навіть якщо це предмет ще не викладається в жодному приміщенні. Це призводить до введення недійсних або неповних даних.

        Щоб уникнути аномалій вставки та привести таблицю до нормальної форми Бойса-Кодда (BCNF), ми можемо розділити її на три окремі таблиці:

        1. Таблиця `Rooms`, що містить інформацію про приміщення:

        | RoomNumber |
        |------------|
        | 101        |
        | 102        |

        2. Таблиця `Professors`, що містить інформацію про викладачів:

        | ProfessorName |
        |---------------|
        | Dr. Smith     |
        | Dr. Johnson   |
        | Dr. Lee       |

        3. Таблиця `Subjects`, що містить інформацію про предмети:

        | Subject    |
        |------------|
        | Mathematics|
        | Physics    |
        | Chemistry  |
        | Biology    |

        4. Таблиця `RoomAssignments`, що зберігає зв'язок між приміщеннями, викладачами і предметами:

        | RoomNumber | ProfessorName | Subject     |
        |------------|---------------|-------------|
        | 101        | Dr. Smith     | Mathematics |
        | 102        | Dr. Johnson   | Physics     |
        | 101        | Dr. Lee       | Chemistry   |

        Тепер ми можемо додати новий предмет до таблиці `Subjects`, навіть якщо він ще не викладається в жодному приміщенні. Це дозволяє уникнути аномалій вставки та забезпечує відповідність нормальної форми Бойса-Кодда (BCNF).

        Таким чином, застосування BCNF допомагає уникати аномалій вставки, забезпечуючи зручне та надійне додавання нових даних до бази даних.


    Аномалії оновлення: Уникнення невідповідностей або помилок при оновленні даних у таблиці.
        
        Аномалії оновлення виникають тоді, коли одні й ті самі дані зберігаються у кількох місцях, і при оновленні одного з них можуть виникнути помилки або невідповідності. Давайте розглянемо приклад на основі нормальної форми Бойса-Кодда (BCNF).

        Припустимо, у нас є таблиця `RoomAssignments`, яка містить інформацію про приміщення, викладачів і предмети:

        | RoomNumber | ProfessorName | Subject     |
        |------------|---------------|-------------|
        | 101        | Dr. Smith     | Mathematics |
        | 102        | Dr. Johnson   | Physics     |
        | 101        | Dr. Smith     | Chemistry   |

        У цьому прикладі атрибут `ProfessorName` дублюється для кожного предмету, який він викладає. Якщо ім'я професора змінюється (наприклад, з `Dr. Smith` на `Dr. Brown`), потрібно оновити всі рядки, де це ім'я зустрічається. Якщо помилково оновити тільки один із рядків, виникнуть невідповідності:

        | RoomNumber | ProfessorName | Subject     |
        |------------|---------------|-------------|
        | 101        | Dr. Brown     | Mathematics |
        | 102        | Dr. Johnson   | Physics     |
        | 101        | Dr. Smith     | Chemistry   |

        Щоб уникнути аномалій оновлення та привести таблицю до нормальної форми Бойса-Кодда (BCNF), потрібно розділити таблицю на три окремі таблиці:

        1. Таблиця `Rooms`, що містить інформацію про приміщення:

        | RoomNumber |
        |------------|
        | 101        |
        | 102        |

        2. Таблиця `Professors`, що містить інформацію про викладачів:

        | ProfessorID | ProfessorName |
        |-------------|---------------|
        | 1           | Dr. Smith     |
        | 2           | Dr. Johnson   |
        | 3           | Dr. Brown     |

        3. Таблиця `Subjects`, що містить інформацію про предмети:

        | SubjectID | Subject     | ProfessorID |
        |-----------|-------------|-------------|
        | 101       | Mathematics | 1           |
        | 102       | Physics     | 2           |
        | 103       | Chemistry   | 1           |

        4. Таблиця `RoomAssignments`, що зберігає зв'язок між приміщеннями і предметами:

        | RoomNumber | SubjectID |
        |------------|-----------|
        | 101        | 101       |
        | 102        | 102       |
        | 101        | 103       |

        Тепер, якщо потрібно оновити ім'я професора з `Dr. Smith` на `Dr. Brown`, це можна зробити лише в одному місці - у таблиці `Professors`. Це зменшує ризик виникнення помилок або невідповідностей і забезпечує відповідність нормальної форми Бойса-Кодда (BCNF).

        Таким чином, застосування BCNF допомагає уникати аномалій оновлення, забезпечуючи коректне та надійне оновлення даних у базах даних.


    Аномалії видалення: Зменшення ризику втрати корисної інформації при видаленні записів із таблиці.
        
        Аномалії видалення виникають тоді, коли видалення одного запису призводить до небажаної втрати іншої важливої інформації. Давайте розглянемо приклад на основі нормальної форми Бойса-Кодда (BCNF).

        Припустимо, у нас є таблиця `CourseAssignments`, яка містить інформацію про курси, викладачів і студентів:

        | CourseID | CourseName | ProfessorName | StudentID | StudentName |
        |----------|------------|---------------|-----------|-------------|
        | 101      | Math       | Dr. Smith     | 1         | Ivanov      |
        | 102      | Physics    | Dr. Johnson   | 2         | Petrov      |
        | 101      | Math       | Dr. Smith     | 3         | Sidorov     |

        У цьому прикладі, якщо ми хочемо видалити запис про курс `Math` (CourseID 101), ми також видалимо інформацію про викладача `Dr. Smith` та студентів `Ivanov` і `Sidorov`. Це призводить до втрати важливої інформації про викладача та студентів, навіть якщо ці дані можуть бути корисними для інших курсів.

        Щоб уникнути аномалій видалення та привести таблицю до нормальної форми Бойса-Кодда (BCNF), ми можемо розділити її на кілька окремих таблиць:

        1. Таблиця `Courses`, що містить інформацію про курси:

        | CourseID | CourseName |
        |----------|------------|
        | 101      | Math       |
        | 102      | Physics    |

        2. Таблиця `Professors`, що містить інформацію про викладачів:

        | ProfessorID | ProfessorName |
        |-------------|---------------|
        | 1           | Dr. Smith     |
        | 2           | Dr. Johnson   |

        3. Таблиця `Students`, що містить інформацію про студентів:

        | StudentID | StudentName |
        |-----------|-------------|
        | 1         | Ivanov      |
        | 2         | Petrov      |
        | 3         | Sidorov     |

        4. Таблиця `CourseProfessors`, що зберігає зв'язок між курсами і викладачами:

        | CourseID | ProfessorID |
        |----------|-------------|
        | 101      | 1           |
        | 102      | 2           |

        5. Таблиця `CourseEnrollments`, що зберігає зв'язок між курсами і студентами:

        | CourseID | StudentID |
        |----------|-----------|
        | 101      | 1         |
        | 102      | 2         |
        | 101      | 3         |

        Тепер, якщо ми хочемо видалити курс `Math` (CourseID 101), ми можемо це зробити, не втрачаючи інформацію про викладача `Dr. Smith` та студентів `Ivanov` і `Sidorov`. Це зменшує ймовірність втрати корисної інформації та забезпечує відповідність нормальної форми Бойса-Кодда (BCNF).

        Таким чином, застосування BCNF допомагає уникати аномалій видалення, забезпечуючи надійне збереження важливої інформації при видаленні даних з бази даних.
    Надлишкові дані: Зменшення дублювання даних, що може призвести до неефективного використання пам'яті та зростання обсягу даних.

    Проблеми з підтримкою цілісності: Покращення підтримки цілісності даних, забезпечуючи коректні зв'язки між даними.

        Проблеми з підтримкою цілісності даних виникають тоді, коли структура таблиці не забезпечує коректні зв'язки між даними, що може призвести до помилок або непослідовностей. Давайте розглянемо приклад на основі нормальної форми Бойса-Кодда (BCNF).

        Припустимо, у нас є таблиця `CourseAssignments`, яка містить інформацію про курси, викладачів і студентів:

        | CourseID | CourseName | ProfessorName | StudentID | StudentName |
        |----------|------------|---------------|-----------|-------------|
        | 101      | Math       | Dr. Smith     | 1         | Ivanov      |
        | 102      | Physics    | Dr. Johnson   | 2         | Petrov      |
        | 101      | Math       | Dr. Smith     | 3         | Sidorov     |

        У цьому прикладі зв'язки між даними не завжди коректні, оскільки атрибут `ProfessorName` дублюється для кожного предмету, який він викладає. Це може призвести до непослідовностей, якщо, наприклад, ім'я викладача змінюється або якщо додати нового викладача до курсу.

        Щоб покращити підтримку цілісності даних та привести таблицю до нормальної форми Бойса-Кодда (BCNF), ми можемо розділити її на кілька окремих таблиць:

        1. Таблиця `Courses`, що містить інформацію про курси:

        | CourseID | CourseName |
        |----------|------------|
        | 101      | Math       |
        | 102      | Physics    |

        2. Таблиця `Professors`, що містить інформацію про викладачів:

        | ProfessorID | ProfessorName |
        |-------------|---------------|
        | 1           | Dr. Smith     |
        | 2           | Dr. Johnson   |

        3. Таблиця `Students`, що містить інформацію про студентів:

        | StudentID | StudentName |
        |-----------|-------------|
        | 1         | Ivanov      |
        | 2         | Petrov      |
        | 3         | Sidorov     |

        4. Таблиця `CourseProfessors`, що зберігає зв'язок між курсами і викладачами:

        | CourseID | ProfessorID |
        |----------|-------------|
        | 101      | 1           |
        | 102      | 2           |

        5. Таблиця `CourseEnrollments`, що зберігає зв'язок між курсами і студентами:

        | CourseID | StudentID |
        |----------|-----------|
        | 101      | 1         |
        | 102      | 2         |
        | 101      | 3         |

        Ця нова структура таблиць забезпечує коректні зв'язки між курсами, викладачами і студентами. Тепер можна легко підтримувати цілісність даних, оскільки зв'язки між даними чітко визначені і зберігаються в окремих таблицях. Це зменшує ризик виникнення помилок або непослідовностей і забезпечує більш ефективне управління даними.

        Таким чином, застосування BCNF допомагає покращити підтримку цілісності даних, забезпечуючи коректні зв'язки між даними у базах даних.


    Ці загальні проблеми часто виникають при роботі з базами даних, і застосування BCNF допомагає їх уникнути, забезпечуючи більш ефективне та надійне управління даними.

Четверта нормальна форма (4NF) допомагає вирішити деякі проблеми, пов'язані з багатозначними залежностями 
в базах даних. Ось основні з них:

1. **Багатозначні залежності**: Уникнення ситуацій, коли один атрибут залежить від іншого атрибуту незалежно 
від третього.

            Багатозначні залежності виникають тоді, коли один атрибут таблиці залежить від іншого атрибуту 
        незалежно від третього атрибуту. Це може призвести до надлишкових даних та аномалій при вставці, оновленні та видаленні даних. Давайте розглянемо приклад.

            Припустимо, у нас є таблиця `EmployeesSkills`, яка містить інформацію про співробітників, 
        їх навички та проекти, в яких вони задіяні:

        | EmployeeID | Skill      | Project   |
        |------------|------------|-----------|
        | 1          | Java       | Project A |
        | 1          | SQL        | Project B |
        | 2          | Python     | Project A |
        | 2          | SQL        | Project C |

            У цьому прикладі навички співробітників (Skill) і проекти (Project) є багатозначними 
        залежностями від EmployeeID. Це означає, що кожен співробітник може мати кілька навичок 
        і одночасно працювати над кількома проектами незалежно один від одного.

            Щоб уникнути багатозначних залежностей і привести таблицю до четвертої нормальної форми (4NF), 
        ми можемо розділити таблицю на дві окремі таблиці:

        1. Таблиця `EmployeeSkills`, що містить інформацію про навички співробітників:

        | EmployeeID | Skill      |
        |------------|------------|
        | 1          | Java       |
        | 1          | SQL        |
        | 2          | Python     |
        | 2          | SQL        |

        2. Таблиця `EmployeeProjects`, що містить інформацію про проекти, в яких задіяні співробітники:

        | EmployeeID | Project   |
        |------------|-----------|
        | 1          | Project A |
        | 1          | Project B |
        | 2          | Project A |
        | 2          | Project C |

            Тепер кожна таблиця містить атомарні залежності між атрибутами, що відповідає вимогам четвертої 
        нормальної форми (4NF). Це усуває багатозначні залежності і зменшує надлишковість даних, 
        забезпечуючи більш ефективне та надійне управління даними.

            Таким чином, застосування 4NF допомагає уникнути багатозначних залежностей, забезпечуючи 
        коректні зв'язки між даними і зменшуючи ризик виникнення аномалій при вставці, оновленні та 
        видаленні даних.

2. **Надлишкові дані**: Зменшення дублювання даних, що може призвести до неефективного використання 
    пам'яті та зростання обсягу даних.
            Надлишкові дані виникають тоді, коли однакова інформація зберігається у кількох місцях, 
        що призводить до дублювання. Це неефективно і може ускладнити підтримку даних. Давайте розглянемо 
        приклад на основі четвертої нормальної форми (4NF).

            Припустимо, у нас є таблиця `EmployeesProjectsSkills`, яка містить інформацію про співробітників, 
        їх навички та проекти, в яких вони задіяні:

        | EmployeeID | EmployeeName | Project   | Skill      |
        |------------|--------------|-----------|------------|
        | 1          | Ivanov       | Project A | Java       |
        | 1          | Ivanov       | Project B | SQL        |
        | 2          | Petrov       | Project A | Python     |
        | 2          | Petrov       | Project C | SQL        |

            У цьому прикладі атрибут `EmployeeName` дублюється у кожному рядку для кожного проекту і навички 
        співробітника. Це створює надлишковість даних.

            Щоб усунути надлишкові дані та привести таблицю до четвертої нормальної форми (4NF), ми можемо 
        розділити її на три окремі таблиці:

        1. Таблиця `Employees`, що містить інформацію про співробітників:

        | EmployeeID | EmployeeName |
        |------------|--------------|
        | 1          | Ivanov       |
        | 2          | Petrov       |

        2. Таблиця `EmployeeProjects`, що містить інформацію про проекти, в яких задіяні співробітники:

        | EmployeeID | Project   |
        |------------|-----------|
        | 1          | Project A |
        | 1          | Project B |
        | 2          | Project A |
        | 2          | Project C |

        3. Таблиця `EmployeeSkills`, що містить інформацію про навички співробітників:

        | EmployeeID | Skill      |
        |------------|------------|
        | 1          | Java       |
        | 1          | SQL        |
        | 2          | Python     |
        | 2          | SQL        |

            Тепер кожна таблиця містить атомарні залежності між атрибутами, що відповідає вимогам 
        четвертої нормальної форми (4NF). Це усуває надлишковість даних, зменшуючи дублювання і 
        забезпечуючи більш ефективне та надійне управління даними.

            Таким чином, застосування 4NF допомагає уникнути надлишкових даних, забезпечуючи коректні 
        зв'язки між даними і зменшуючи ризик виникнення аномалій при вставці, оновленні та видаленні даних.

3. **Аномалії вставки**: Зниження ймовірності виникнення проблем при додаванні нових даних до таблиці.
    
        Аномалії вставки виникають тоді, коли існує необхідність додати новий запис до таблиці, 
    але через структуру таблиці це стає проблематичним або неможливим без введення надлишкових або неповних даних. 
    Давайте розглянемо приклад на основі четвертої нормальної форми (4NF).

        Припустимо, у нас є таблиця `ProductOrders`, яка містить інформацію про замовлення продуктів 
    і їх постачальників:

    | OrderID | ProductID | ProductName | SupplierName |
    |---------|-----------|-------------|--------------|
    | 1       | 101       | Apple       | Supplier A   |
    | 1       | 102       | Banana      | Supplier B   |
    | 2       | 101       | Apple       | Supplier A   |
    | 2       | 103       | Orange      | Supplier C   |

        У цій таблиці, якщо ми хочемо додати новий продукт, який ще не має постачальника, ми можемо зіткнутися 
    з аномалією вставки. Наприклад, для додавання продукту `Grapes`, нам потрібно вказати значення для 
    `OrderID` та `SupplierName`, навіть якщо цього продукту ще немає в жодному замовленні. 
    Це призводить до введення недійсних або неповних даних.

        Щоб уникнути аномалій вставки та привести таблицю до четвертої нормальної форми (4NF), 
    ми можемо розділити її на три окремі таблиці:

    1. Таблиця `Products`, що містить інформацію про продукти:

    | ProductID | ProductName |
    |-----------|-------------|
    | 101       | Apple       |
    | 102       | Banana      |
    | 103       | Orange      |
    | 104       | Grapes      |

    2. Таблиця `Suppliers`, що містить інформацію про постачальників:

    | SupplierID | SupplierName |
    |------------|--------------|
    | 1          | Supplier A   |
    | 2          | Supplier B   |
    | 3          | Supplier C   |

    3. Таблиця `ProductSuppliers`, що зберігає зв'язок між продуктами і постачальниками:

    | ProductID | SupplierID |
    |-----------|------------|
    | 101       | 1          |
    | 102       | 2          |
    | 103       | 3          |

    4. Таблиця `Orders`, що зберігає зв'язок між замовленнями і продуктами:

    | OrderID | ProductID |
    |---------|-----------|
    | 1       | 101       |
    | 1       | 102       |
    | 2       | 101       |
    | 2       | 103       |

        Тепер ми можемо додати новий продукт до таблиці `Products`, навіть якщо він ще не має постачальника 
    або не включений у жодне замовлення. Це дозволяє уникнути аномалій вставки та забезпечує відповідність 
    четвертій нормальній формі (4NF).

        Таким чином, застосування 4NF допомагає уникати аномалій вставки, забезпечуючи зручне та надійне 
    додавання нових даних до бази даних.

4. **Аномалії оновлення**: Уникнення невідповідностей або помилок при оновленні даних у таблиці.

            Аномалії оновлення виникають тоді, коли одні й ті самі дані зберігаються у кількох місцях, 
        і при оновленні одного з них можуть виникнути помилки або невідповідності. Давайте розглянемо 
        приклад на основі четвертої нормальної форми (4NF).

            Припустимо, у нас є таблиця `ProductOrders`, яка містить інформацію про замовлення продуктів, 
        їх постачальників і клієнтів:

        | OrderID | ProductID | ProductName | SupplierName | CustomerID | CustomerName |
        |---------|-----------|-------------|--------------|------------|--------------|
        | 1       | 101       | Apple       | Supplier A   | 201        | Ivanov       |
        | 1       | 102       | Banana      | Supplier B   | 202        | Petrov       |
        | 2       | 101       | Apple       | Supplier A   | 203        | Sidorov      |

            У цьому прикладі атрибут `SupplierName` дублюється у кожному рядку для кожного продукту, і атрибут 
        `CustomerName` дублюється для кожного замовлення. Якщо ім'я постачальника змінюється (наприклад, 
        з `Supplier A` на `Supplier X`), потрібно оновити всі рядки, де це ім'я зустрічається. 
        Якщо помилково оновити тільки один із рядків, виникнуть невідповідності:

        | OrderID | ProductID | ProductName | SupplierName | CustomerID | CustomerName |
        |---------|-----------|-------------|--------------|------------|--------------|
        | 1       | 101       | Apple       | Supplier X   | 201        | Ivanov       |
        | 1       | 102       | Banana      | Supplier B   | 202        | Petrov       |
        | 2       | 101       | Apple       | Supplier A   | 203        | Sidorov      |

            Щоб уникнути аномалій оновлення та привести таблицю до четвертої нормальної форми (4NF), 
        потрібно розділити таблицю на кілька окремих таблиць:

        1. Таблиця `Products`, що містить інформацію про продукти:

        | ProductID | ProductName |
        |-----------|-------------|
        | 101       | Apple       |
        | 102       | Banana      |

        2. Таблиця `Suppliers`, що містить інформацію про постачальників:

        | SupplierID | SupplierName |
        |------------|--------------|
        | 1          | Supplier A   |
        | 2          | Supplier B   |
        | 3          | Supplier X   |

        3. Таблиця `Customers`, що містить інформацію про клієнтів:

        | CustomerID | CustomerName |
        |------------|--------------|
        | 201        | Ivanov       |
        | 202        | Petrov       |
        | 203        | Sidorov      |

        4. Таблиця `ProductSuppliers`, що зберігає зв'язок між продуктами і постачальниками:

        | ProductID | SupplierID |
        |-----------|------------|
        | 101       | 1          |
        | 102       | 2          |

        5. Таблиця `Orders`, що зберігає зв'язок між замовленнями і продуктами, а також клієнтами:

        | OrderID | ProductID | CustomerID |
        |---------|-----------|------------|
        | 1       | 101       | 201        |
        | 1       | 102       | 202        |
        | 2       | 101       | 203        |

            Тепер, якщо потрібно оновити ім'я постачальника з `Supplier A` на `Supplier X`, це можна зробити 
        лише в одному місці - у таблиці `Suppliers`. Це зменшує ризик виникнення помилок або невідповідностей 
        і забезпечує відповідність четвертій нормальній формі (4NF).

            Таким чином, застосування 4NF допомагає уникати аномалій оновлення, забезпечуючи коректне та надійне оновлення даних у базах даних.

5. **Аномалії видалення**: Зменшення ризику втрати корисної інформації при видаленні записів із таблиці.

        Аномалії видалення виникають тоді, коли видалення одного запису призводить до небажаної втрати 
    іншої важливої інформації. Давайте розглянемо приклад на основі четвертої нормальної форми (4NF).

        Припустимо, у нас є таблиця `EmployeeProjectsSkills`, яка містить інформацію про співробітників, 
    їх навички та проекти, в яких вони задіяні:

        | EmployeeID | EmployeeName | Project   | Skill      |
        |------------|--------------|-----------|------------|
        | 1          | Ivanov       | Project A | Java       |
        | 1          | Ivanov       | Project B | SQL        |
        | 2          | Petrov       | Project A | Python     |
        | 2          | Petrov       | Project C | SQL        |

        У цьому прикладі, якщо ми хочемо видалити запис про проект `Project A`, це призведе до видалення 
    всіх рядків, пов'язаних з цим проектом, включаючи інформацію про навички співробітників `Ivanov` і `Petrov`, 
    навіть якщо ці навички можуть бути корисними для інших проектів. Це є аномалією видалення.

        Щоб уникнути аномалій видалення та привести таблицю до четвертої нормальної форми (4NF), ми можемо 
    розділити її на три окремі таблиці:

        1. Таблиця `Employees`, що містить інформацію про співробітників:

        | EmployeeID | EmployeeName |
        |------------|--------------|
        | 1          | Ivanov       |
        | 2          | Petrov       |

        2. Таблиця `EmployeeProjects`, що містить інформацію про проекти, в яких задіяні співробітники:

        | EmployeeID | Project   |
        |------------|-----------|
        | 1          | Project A |
        | 1          | Project B |
        | 2          | Project A |
        | 2          | Project C |

        3. Таблиця `EmployeeSkills`, що містить інформацію про навички співробітників:

        | EmployeeID | Skill      |
        |------------|------------|
        | 1          | Java       |
        | 1          | SQL        |
        | 2          | Python     |
        | 2          | SQL        |

        Тепер, якщо ми хочемо видалити проект `Project A`, ми можемо зробити це в таблиці `EmployeeProjects`, 
    не втрачаючи інформацію про навички співробітників `Ivanov` і `Petrov`, які зберігаються в таблиці 
    `EmployeeSkills`. Це зменшує ймовірність втрати корисної інформації та забезпечує відповідність 
    четвертій нормальній формі (4NF).

        Таким чином, застосування 4NF допомагає уникати аномалій видалення, забезпечуючи надійне збереження важливої інформації при видаленні даних з бази даних.


6. **Проблеми з підтримкою цілісності**: Покращення підтримки цілісності даних, забезпечуючи коректні 
    зв'язки між даними.

            Проблеми з підтримкою цілісності даних виникають тоді, коли структура таблиці не забезпечує 
        коректні зв'язки між даними, що може призвести до помилок або непослідовностей. Давайте розглянемо 
        приклад на основі четвертої нормальної форми (4NF).

            Припустимо, у нас є таблиця `StudentEnrollments`, яка містить інформацію про студентів, курси 
        і викладачів:

        | StudentID | StudentName | CourseID | CourseName | ProfessorName |
        |-----------|-------------|----------|------------|---------------|
        | 1         | Ivanov      | 101      | Math       | Dr. Smith     |
        | 2         | Petrov      | 102      | Physics    | Dr. Johnson   |
        | 1         | Ivanov      | 103      | Chemistry  | Dr. Lee       |

            У цьому прикладі зв'язки між даними не завжди коректні, оскільки атрибут `ProfessorName` 
        дублюється для кожного курсу, на якому викладає професор. Це може призвести до непослідовностей, 
        якщо, наприклад, ім'я професора змінюється або додається новий професор.

            Щоб покращити підтримку цілісності даних та привести таблицю до четвертої нормальної форми (4NF), 
        ми можемо розділити її на кілька окремих таблиць:

        1. Таблиця `Students`, що містить інформацію про студентів:

        | StudentID | StudentName |
        |-----------|-------------|
        | 1         | Ivanov      |
        | 2         | Petrov      |

        2. Таблиця `Courses`, що містить інформацію про курси:

        | CourseID | CourseName |
        |----------|------------|
        | 101      | Math       |
        | 102      | Physics    |
        | 103      | Chemistry  |

        3. Таблиця `Professors`, що містить інформацію про викладачів:

        | ProfessorID | ProfessorName |
        |-------------|---------------|
        | 1           | Dr. Smith     |
        | 2           | Dr. Johnson   |
        | 3           | Dr. Lee       |

        4. Таблиця `CourseProfessors`, що зберігає зв'язок між курсами і викладачами:

        | CourseID | ProfessorID |
        |----------|-------------|
        | 101      | 1           |
        | 102      | 2           |
        | 103      | 3           |

        5. Таблиця `StudentEnrollments`, що зберігає зв'язок між студентами і курсами:

        | StudentID | CourseID |
        |-----------|----------|
        | 1         | 101      |
        | 2         | 102      |
        | 1         | 103      |

            Ця нова структура таблиць забезпечує коректні зв'язки між студентами, курсами і викладачами. 
        Тепер можна легко підтримувати цілісність даних, оскільки зв'язки між даними чітко визначені і 
        зберігаються в окремих таблицях. Це зменшує ризик виникнення помилок або непослідовностей і 
        забезпечує більш ефективне управління даними.

        Таким чином, застосування 4NF допомагає покращити підтримку цілісності даних, забезпечуючи 
        коректні зв'язки між даними у базах даних.

    Ці загальні проблеми часто виникають при роботі з базами даних, і застосування 4NF допомагає їх уникнути,
забезпечуючи більш ефективне та надійне управління даними.

П'ята нормальна форма (5NF) допомагає вирішити деякі проблеми, пов'язані зі сполученнями в базах даних. 
Ось основні з них:

1. **Складні сполучення**: Уникнення ситуацій, коли таблиця повинна розбиватися на декілька окремих 
таблиць для збереження сполучень.

    Складні сполучення виникають тоді, коли одна таблиця повинна бути розбита на кілька окремих таблиць для збереження зв'язків між даними. Це може призвести до надлишкових даних і аномалій при вставці, оновленні та видаленні. Давайте розглянемо приклад на основі п'ятої нормальної форми (5NF).

        Припустимо, у нас є таблиця `ProjectAssignments`, яка містить інформацію про співробітників, проекти та їхні ролі в проектах:

        | EmployeeID | ProjectID | Role         |
        |------------|-----------|--------------|
        | 1          | 101       | Developer    |
        | 1          | 102       | Team Lead    |
        | 2          | 101       | Tester       |
        | 2          | 103       | Developer    |
        | 3          | 102       | Developer    |
        | 3          | 103       | Team Lead    |

        У цьому прикладі один співробітник може працювати над кількома проектами і мати різні ролі в кожному проекті. Це створює складні сполучення між співробітниками, проектами та ролями.

        Щоб привести таблицю до п'ятої нормальної форми (5NF) і уникнути складних сполучень, ми можемо розділити таблицю на три окремі таблиці:

        1. Таблиця `Employees`, що містить інформацію про співробітників:

        | EmployeeID | EmployeeName |
        |------------|--------------|
        | 1          | Ivanov       |
        | 2          | Petrov       |
        | 3          | Sidorov      |

        2. Таблиця `Projects`, що містить інформацію про проекти:

        | ProjectID | ProjectName |
        |-----------|-------------|
        | 101       | Project A   |
        | 102       | Project B   |
        | 103       | Project C   |

        3. Таблиця `Roles`, що містить інформацію про ролі співробітників у проектах:

        | RoleID | RoleName    |
        |--------|-------------|
        | 1      | Developer   |
        | 2      | Team Lead   |
        | 3      | Tester      |

        4. Таблиця `ProjectAssignments`, що зберігає зв'язок між співробітниками, проектами і ролями:

        | EmployeeID | ProjectID | RoleID |
        |------------|-----------|--------|
        | 1          | 101       | 1      |
        | 1          | 102       | 2      |
        | 2          | 101       | 3      |
        | 2          | 103       | 1      |
        | 3          | 102       | 1      |
        | 3          | 103       | 2      |

        Тепер кожна таблиця містить атомарні залежності між атрибутами, що відповідає вимогам п'ятої нормальної форми (5NF). Це усуває складні сполучення і зменшує надлишковість даних, забезпечуючи більш ефективне та надійне управління даними.

        Таким чином, застосування 5NF допомагає уникнути складних сполучень, забезпечуючи коректні зв'язки між даними і зменшуючи ризик виникнення аномалій при вставці, оновленні та видаленні даних.

2. **Надлишкові дані**: Зменшення дублювання даних, що може призвести до неефективного використання 
пам'яті та зростання обсягу даних.

        Надлишкові дані виникають тоді, коли однакова інформація зберігається у кількох місцях, що призводить 
    до дублювання. Це неефективно і може ускладнити підтримку даних. Давайте розглянемо приклад на 
    основі п'ятої нормальної форми (5NF).

        Припустимо, у нас є таблиця `EmployeeProjects`, яка містить інформацію про співробітників і проекти, 
    в яких вони задіяні:

        | EmployeeID | EmployeeName | ProjectID | ProjectName |
        |------------|--------------|-----------|-------------|
        | 1          | Ivanov       | 101       | Project A   |
        | 1          | Ivanov       | 102       | Project B   |
        | 2          | Petrov       | 101       | Project A   |
        | 2          | Petrov       | 103       | Project C   |
        | 3          | Sidorov      | 102       | Project B   |
        | 3          | Sidorov      | 103       | Project C   |

        У цьому прикладі атрибути `EmployeeName` і `ProjectName` дублюються у кількох рядках для кожного 
    співробітника і проекту. Це створює надлишковість даних.

        Щоб усунути надлишкові дані та привести таблицю до п'ятої нормальної форми (5NF), ми можемо розділити 
    її на кілька окремих таблиць:

        1. Таблиця `Employees`, що містить інформацію про співробітників:

        | EmployeeID | EmployeeName |
        |------------|--------------|
        | 1          | Ivanov       |
        | 2          | Petrov       |
        | 3          | Sidorov      |

        2. Таблиця `Projects`, що містить інформацію про проекти:

        | ProjectID | ProjectName |
        |-----------|-------------|
        | 101       | Project A   |
        | 102       | Project B   |
        | 103       | Project C   |

        3. Таблиця `EmployeeProjects`, що зберігає зв'язок між співробітниками і проектами:

        | EmployeeID | ProjectID |
        |------------|-----------|
        | 1          | 101       |
        | 1          | 102       |
        | 2          | 101       |
        | 2          | 103       |
        | 3          | 102       |
        | 3          | 103       |

        Тепер кожна таблиця містить атомарні залежності між атрибутами, що відповідає вимогам п'ятої 
    нормальної форми (5NF). Це усуває надлишковість даних, зменшуючи дублювання і забезпечуючи більш 
    ефективне та надійне управління даними.

        Таким чином, застосування 5NF допомагає уникнути надлишкових даних, забезпечуючи коректні зв'язки 
    між даними і зменшуючи ризик виникнення аномалій при вставці, оновленні та видаленні даних.

3. **Аномалії вставки**: Уникнення проблем, які можуть виникати при додаванні нових даних до таблиці.

        Аномалії вставки виникають тоді, коли структура таблиці створює проблеми при додаванні нових записів. 
    Давайте розглянемо приклад на основі п'ятої нормальної форми (5NF).

        Припустимо, у нас є таблиця `CourseAssignments`, яка містить інформацію про курси, викладачів і студентів:

        | CourseID | CourseName | ProfessorName | StudentID | StudentName |
        |----------|------------|---------------|-----------|-------------|
        | 101      | Math       | Dr. Smith     | 1         | Ivanov      |
        | 102      | Physics    | Dr. Johnson   | 2         | Petrov      |
        | 103      | Chemistry  | Dr. Lee       | 3         | Sidorov     |

        У цьому прикладі, якщо ми хочемо додати нового студента, який поки що не записаний на жоден курс, 
    ми можемо зіткнутися з аномалією вставки. Наприклад, для додавання студента `Kozlov`, нам потрібно 
    вказати значення для `CourseID`, `CourseName` і `ProfessorName`, навіть якщо цей студент ще не записаний 
    на жоден курс. Це призводить до введення недійсних або неповних даних.

        Щоб уникнути аномалій вставки та привести таблицю до п'ятої нормальної форми (5NF), ми можемо розділити
    її на кілька окремих таблиць:

        1. Таблиця `Students`, що містить інформацію про студентів:

        | StudentID | StudentName |
        |-----------|-------------|
        | 1         | Ivanov      |
        | 2         | Petrov      |
        | 3         | Sidorov     |
        | 4         | Kozlov      |

        2. Таблиця `Courses`, що містить інформацію про курси:

        | CourseID | CourseName |
        |----------|------------|
        | 101      | Math       |
        | 102      | Physics    |
        | 103      | Chemistry  |

        3. Таблиця `Professors`, що містить інформацію про викладачів:

        | ProfessorID | ProfessorName |
        |-------------|---------------|
        | 1           | Dr. Smith     |
        | 2           | Dr. Johnson   |
        | 3           | Dr. Lee       |

        4. Таблиця `CourseProfessors`, що зберігає зв'язок між курсами і викладачами:

        | CourseID | ProfessorID |
        |----------|-------------|
        | 101      | 1           |
        | 102      | 2           |
        | 103      | 3           |

        5. Таблиця `CourseEnrollments`, що зберігає зв'язок між студентами і курсами:

        | CourseID | StudentID |
        |----------|-----------|
        | 101      | 1         |
        | 102      | 2         |
        | 103      | 3         |

        Тепер ми можемо додати нового студента до таблиці `Students`, навіть якщо він поки що не записаний на 
    жоден курс. Це дозволяє уникнути аномалій вставки та забезпечує відповідність п'ятій нормальній формі (5NF).

        Таким чином, застосування 5NF допомагає уникати аномалій вставки, забезпечуючи зручне та надійне 
    додавання нових даних до бази даних.

4. **Аномалії оновлення**: Зниження ризику виникнення помилок або невідповідностей при оновленні даних.

    Аномалії оновлення виникають тоді, коли одні й ті самі дані зберігаються у кількох місцях, і при 
    оновленні одного з них можуть виникнути помилки або невідповідності. Давайте розглянемо приклад на 
    основі п'ятої нормальної форми (5NF).

        Припустимо, у нас є таблиця `CourseAssignments`, яка містить інформацію про курси, викладачів і студентів:

        | CourseID | CourseName | ProfessorName | StudentID | StudentName |
        |----------|------------|---------------|-----------|-------------|
        | 101      | Math       | Dr. Smith     | 1         | Ivanov      |
        | 102      | Physics    | Dr. Johnson   | 2         | Petrov      |
        | 103      | Chemistry  | Dr. Lee       | 3         | Sidorov     |

        У цьому прикладі атрибут `ProfessorName` дублюється для кожного курсу, на якому викладає професор. 
        Якщо ім'я професора змінюється (наприклад, з `Dr. Smith` на `Dr. Brown`), потрібно оновити всі рядки, 
        де це ім'я зустрічається. Якщо помилково оновити тільки один із рядків, виникнуть невідповідності:

        | CourseID | CourseName | ProfessorName | StudentID | StudentName |
        |----------|------------|---------------|-----------|-------------|
        | 101      | Math       | Dr. Brown     | 1         | Ivanov      |
        | 102      | Physics    | Dr. Johnson   | 2         | Petrov      |
        | 103      | Chemistry  | Dr. Smith     | 3         | Sidorov     |

        Щоб уникнути аномалій оновлення та привести таблицю до п'ятої нормальної форми (5NF), потрібно розділити 
        таблицю на кілька окремих таблиць:

        1. Таблиця `Students`, що містить інформацію про студентів:

        | StudentID | StudentName |
        |-----------|-------------|
        | 1         | Ivanov      |
        | 2         | Petrov      |
        | 3         | Sidorov     |

        2. Таблиця `Courses`, що містить інформацію про курси:

        | CourseID | CourseName |
        |----------|------------|
        | 101      | Math       |
        | 102      | Physics    |
        | 103      | Chemistry  |

        3. Таблиця `Professors`, що містить інформацію про викладачів:

        | ProfessorID | ProfessorName |
        |-------------|---------------|
        | 1           | Dr. Smith     |
        | 2           | Dr. Johnson   |
        | 3           | Dr. Brown     |

        4. Таблиця `CourseProfessors`, що зберігає зв'язок між курсами і викладачами:

        | CourseID | ProfessorID |
        |----------|-------------|
        | 101      | 3           |
        | 102      | 2           |
        | 103      | 1           |

        5. Таблиця `CourseEnrollments`, що зберігає зв'язок між студентами і курсами:

        | CourseID | StudentID |
        |----------|-----------|
        | 101      | 1         |
        | 102      | 2         |
        | 103      | 3         |

        Тепер, якщо потрібно оновити ім'я професора з `Dr. Smith` на `Dr. Brown`, це можна зробити лише в одному 
        місці - у таблиці `Professors`. Це зменшує ризик виникнення помилок або невідповідностей і забезпечує 
        відповідність п'ятій нормальній формі (5NF).

        Таким чином, застосування 5NF допомагає уникати аномалій оновлення, забезпечуючи коректне та надійне    
        оновлення даних у базах даних.

5. **Аномалії видалення**: Зменшення ризику втрати корисної інформації при видаленні записів із таблиці.
    
            Аномалії видалення виникають тоді, коли видалення одного запису призводить до небажаної втрати 
        іншої важливої інформації. Давайте розглянемо приклад на основі п'ятої нормальної форми (5NF).

        Припустимо, у нас є таблиця `OrderDetails`, яка містить інформацію про замовлення, продукти і 
        постачальників:

        | OrderID | ProductID | ProductName | SupplierName |
        |---------|-----------|-------------|--------------|
        | 1       | 101       | Apple       | Supplier A   |
        | 2       | 102       | Banana      | Supplier B   |
        | 3       | 101       | Apple       | Supplier A   |
        | 3       | 103       | Orange      | Supplier C   |

        У цьому прикладі, якщо ми хочемо видалити замовлення `Order 3`, це призведе до видалення всіх рядків, 
        пов'язаних з цим замовленням, включаючи інформацію про продукт `Apple` і постачальника `Supplier A`. 
        Це є аномалією видалення, оскільки ми втрачаємо важливу інформацію, яка може бути корисною для інших 
        замовлень.

        Щоб уникнути аномалій видалення та привести таблицю до п'ятої нормальної форми (5NF), ми можемо 
        розділити її на кілька окремих таблиць:

        1. Таблиця `Products`, що містить інформацію про продукти:

        | ProductID | ProductName |
        |-----------|-------------|
        | 101       | Apple       |
        | 102       | Banana      |
        | 103       | Orange      |

        2. Таблиця `Suppliers`, що містить інформацію про постачальників:

        | SupplierID | SupplierName |
        |------------|--------------|
        | 1          | Supplier A   |
        | 2          | Supplier B   |
        | 3          | Supplier C   |

        3. Таблиця `ProductSuppliers`, що зберігає зв'язок між продуктами і постачальниками:

        | ProductID | SupplierID |
        |-----------|------------|
        | 101       | 1          |
        | 102       | 2          |
        | 103       | 3          |

        4. Таблиця `Orders`, що зберігає інформацію про замовлення:

        | OrderID |
        |---------|
        | 1       |
        | 2       |
        | 3       |

        5. Таблиця `OrderDetails`, що зберігає зв'язок між замовленнями і продуктами:

        | OrderID | ProductID |
        |---------|-----------|
        | 1       | 101       |
        | 2       | 102       |
        | 3       | 101       |
        | 3       | 103       |

        Тепер, якщо ми хочемо видалити замовлення `Order 3`, ми можемо це зробити, не втрачаючи інформацію 
        про продукт `Apple` і постачальника `Supplier A`, які зберігаються в окремих таблицях `Products` і 
        `Suppliers`. Це зменшує ймовірність втрати корисної інформації та забезпечує відповідність п'ятій 
        нормальній формі (5NF).

        Таким чином, застосування 5NF допомагає уникати аномалій видалення, забезпечуючи надійне збереження важливої інформації при видаленні даних з бази даних.

6. **Проблеми з підтримкою цілісності**: Покращення підтримки цілісності даних, забезпечуючи коректні 
зв'язки між даними.

            Проблеми з підтримкою цілісності даних виникають тоді, коли структура таблиці не забезпечує 
        коректні зв'язки між даними, що може призвести до помилок або непослідовностей. Давайте розглянемо 
        приклад на основі п'ятої нормальної форми (5NF).

        Припустимо, у нас є таблиця `EmployeeProjects`, яка містить інформацію про співробітників, проекти і ролі:

        | EmployeeID | EmployeeName | ProjectID | ProjectName | Role         |
        |------------|--------------|-----------|-------------|--------------|
        | 1          | Ivanov       | 101       | Project A   | Developer    |
        | 2          | Petrov       | 102       | Project B   | Tester       |
        | 1          | Ivanov       | 103       | Project C   | Team Lead    |
        | 3          | Sidorov      | 101       | Project A   | Developer    |

            У цій таблиці зв'язки між даними не завжди коректні, оскільки атрибути `EmployeeName`, `ProjectName` 
        і `Role` дублюються у кількох рядках. Це може призвести до непослідовностей, якщо, наприклад, 
        ім'я співробітника змінюється або додається новий проект.

            Щоб покращити підтримку цілісності даних та привести таблицю до п'ятої нормальної форми (5NF), 
        ми можемо розділити її на кілька окремих таблиць:

        1. Таблиця `Employees`, що містить інформацію про співробітників:

        | EmployeeID | EmployeeName |
        |------------|--------------|
        | 1          | Ivanov       |
        | 2          | Petrov       |
        | 3          | Sidorov      |

        2. Таблиця `Projects`, що містить інформацію про проекти:

        | ProjectID | ProjectName |
        |-----------|-------------|
        | 101       | Project A   |
        | 102       | Project B   |
        | 103       | Project C   |

        3. Таблиця `Roles`, що містить інформацію про ролі співробітників:

        | RoleID | Role         |
        |--------|--------------|
        | 1      | Developer    |
        | 2      | Tester       |
        | 3      | Team Lead    |

        4. Таблиця `EmployeeProjects`, що зберігає зв'язок між співробітниками, проектами і ролями:

        | EmployeeID | ProjectID | RoleID |
        |------------|-----------|--------|
        | 1          | 101       | 1      |
        | 2          | 102       | 2      |
        | 1          | 103       | 3      |
        | 3          | 101       | 1      |

            Ця нова структура таблиць забезпечує коректні зв'язки між співробітниками, проектами і ролями. 
        Тепер можна легко підтримувати цілісність даних, оскільки зв'язки між даними чітко визначені і 
        зберігаються в окремих таблицях. Це зменшує ризик виникнення помилок або непослідовностей і     
        забезпечує більш ефективне управління даними.

            Таким чином, застосування 5NF допомагає покращити підтримку цілісності даних, 
        забезпечуючи коректні зв'язки між даними у базах даних.

Ці загальні проблеми часто виникають при роботі з базами даних, і застосування 5NF допомагає їх уникнути, забезпечуючи більш ефективне та надійне управління даними.


Нормальні форми в теорії баз даних - це правила, 
що застосовуються до схем баз даних для зменшення надлишковості 
та усунення аномалій при операціях вставки, оновлення та видалення. 
Існує кілька нормальних форм, кожна з яких розв'язує певний набір проблем. 
Ось основні з них:

1. **Перша нормальна форма (1НФ)**: 
Вимога, щоб усі атрибути таблиці містили лише атомарні (неподільні) значення. 
Іншими словами, кожне значення в колонці має бути єдиним і неподільним.

2. **Друга нормальна форма (2НФ)**: Вимога, щоб таблиця була в 1НФ, 
і всі неключові атрибути повністю залежали від первинного ключа. 
Це означає, що кожен неключовий атрибут має залежати від всього первинного ключа, 
а не від його частини.

3. **Третя нормальна форма (3НФ)**: Вимога, щоб таблиця була в 2НФ, 
і всі неключові атрибути були незалежні один від одного та залежали лише від первинного ключа. 
Іншими словами, не повинно бути транзитивних залежностей між неключовими атрибутами.

4. **Бойс-Кодд нормальна форма (BCNF)**: Вимога, щоб таблиця була в 3НФ, 
і кожен детермінант був суперключем. Це означає, що для будь-якої функціональної 
залежності X → Y, X має бути суперключем.

5. **Четверта нормальна форма (4НФ)**: Вимога, щоб таблиця була в BCNF, 
і не було багатозначних залежностей. Це означає, що для кожного атрибуту він має 
бути однозначно визначений первинним ключем, навіть при наявності множинних зв'язків.

6. **П'ята нормальна форма (5НФ)**: Вимога, щоб таблиця була в 4НФ і не мала залежностей з'єднань. 
Це означає, що дані не повинні мати прихованих залежностей, 
які можна розбити на кілька таблиць без втрати інформації.

Нормалізація є важливою частиною проєктування баз даних, 
оскільки вона допомагає забезпечити цілісність даних, 
знижує надлишковість та мінімізує аномалії при виконанні операцій з даними.

*/