using System;
using System.Data.SqlClient;

/*

"CAP-теорема" або теорема Брюера є важливою концепцією в сфері розподілених обчислень. 
Основна ідея полягає в тому, що у розподіленій системі можна одночасно досягти лише двох із трьох властивостей:

1. **Consistency (консистентність): Усі вузли системи бачать однакові дані в один і той же момент часу.
2. **Availability (доступність): Кожен запит від клієнта отримує відповідь, незалежно від стану окремих вузлів.
3. **Partition Tolerance (стійкість до розділу): Система продовжує працювати, незважаючи на мережеві розриви або поділи.

Тобто, якщо є мережевий розрив (розділ), необхідно зробити вибір між консистентністю та доступністю, 
оскільки одночасно досягти усіх трьох властивостей неможливо. Це дуже корисна концепція для розуміння компромісів 
при проектуванні розподілених систем.

Консистентність у розподілених системах означає, що всі вузли системи бачать однакові дані одночасно. 
Уяви, що ти працюєш з базою даних, яка розподілена по кількох серверах. Коли ти виконуєш оновлення даних, 
консистентність гарантує, що всі сервери отримують однакове оновлення в той же момент часу.

На практиці це часто реалізується через механізми транзакцій. Наприклад, у реляційних базах даних 
використовується принцип ACID (Atomicity, Consistency, Isolation, Durability). Консистентність тут означає, 
що будь-яка транзакція переводить базу даних з одного валідного стану в інший валідний стан, підтримуючи всі правила 
і обмеження цілісності даних.

Щоб краще це уявити, розглянемо приклад інтернет-магазину:
1. Користувач додає товар до кошика.
2. База даних оновлює кількість товару на складі.

У системі з високим рівнем консистентності, якщо ти оновиш кількість товару на складі, 
всі сервери одразу побачать це оновлення, і інші користувачі не зможуть додати до своїх кошиків більше товару, 
ніж є на складі.

Консистентність може бути складно підтримувати у великих розподілених системах, особливо при високій навантаженості, 
тому часто розробники вдаються до компромісів, балансуючи між консистентністю, доступністю та стійкістю до розділу, 
згідно з CAP-теоремою.

ACID є скороченням для чотирьох властивостей, які гарантують надійність транзакцій у базах даних. Це:

1. **Atomicity (Атомарність)**:
    - Атомарність означає, що транзакція є неподільною одиницею роботи, яка або виконується повністю, 
або не виконується взагалі. Тобто, якщо будь-яка частина транзакції не виконується успішно, всі зміни, 
які були зроблені до цього моменту, відміняються (відкочуються). Атомарність забезпечує цілісність системи навіть у разі 
збоїв.
  
2. **Consistency (Консистентність)**:
    - Консистентність гарантує, що будь-яка транзакція переводить базу даних з одного валідного стану в інший валідний стан. 
Це означає, що всі правила і обмеження цілісності даних дотримуються після завершення транзакції. Система завжди 
залишається у консистентному стані.

3. **Isolation (Ізоляція)**:
    - Ізоляція забезпечує, що одночасні транзакції не впливають одна на одну. Навіть якщо кілька транзакцій виконуються 
одночасно, кожна з них повинна відбуватися так, ніби вона є єдиною. Це запобігає побічним ефектам від одночасного доступу 
до даних.

4. **Durability (Надійність)**:
    - Надійність гарантує, що після успішного завершення транзакції її результати будуть постійно зберігатися у базі даних, 
навіть у разі системних збоїв або відключень живлення. Це забезпечує довговічність даних, що зберігаються.

Ось простий приклад того, як ці принципи застосовуються на практиці у контексті інтернет-магазину:
- **Атомарність**: Коли ти здійснюєш покупку, система повинна одночасно зменшити кількість товару на складі 
та зафіксувати продаж. Якщо одна з цих операцій не виконується, інша також повинна бути скасована.
- **Консистентність**: Після завершення покупки система повинна перевірити, що кількість товару на складі коректно 
оновлена відповідно до правил магазину.
- **Ізоляція**: Якщо інший користувач одночасно купує той же товар, його транзакція не повинна впливати на твою, і навпаки.
- **Надійність**: Якщо транзакція з покупкою завершена, дані про покупку зберігаються назавжди, навіть у разі 
непередбачених збоїв.

Доступність (Availability) в контексті CAP-теореми означає, що кожен запит від клієнта отримує відповідь, 
незалежно від стану окремих вузлів у розподіленій системі. Навіть якщо кілька серверів виходять з ладу або мережевий 
зв'язок між ними порушується, система повинна забезпечувати можливість обробки запитів клієнтів.

На практиці це означає, що для досягнення високої доступності, системи часто використовують такі техніки, 
як реплікація даних і балансування навантаження. Ось деякі приклади:

1. **Реплікація даних**:
   - Дані копіюються на кілька серверів. Якщо один сервер виходить з ладу, інші можуть продовжувати 
обслуговувати запити клієнтів. Це підвищує стійкість до збоїв.

2. **Балансування навантаження**:
   - Запити клієнтів розподіляються між кількома серверами, що зменшує навантаження на окремі вузли та забезпечує 
більш рівномірний розподіл ресурсів.

3. **Автоматичне перемикання**:
   - Якщо один сервер виходить з ладу, система автоматично перемикається на інший доступний сервер, забезпечуючи 
безперервність обслуговування.

4. **Кешування**:
   - Кешування даних дозволяє швидше обробляти запити, зменшуючи навантаження на основні бази даних.

Прикладом системи з високою доступністю є розподілені бази даних, такі як Apache Cassandra або Amazon DynamoDB. 
Вони забезпечують доступність даних навіть у разі збоїв окремих вузлів або мережевих проблем.

Доступність є критично важливою для систем, що вимагають безперервного обслуговування, наприклад, для інтернет-магазинів, 
банківських систем або соціальних мереж. Висока доступність гарантує, що користувачі завжди можуть отримати доступ 
до своїх даних і сервісів, навіть якщо деякі частини системи тимчасово недоступні.


Стійкість до розділу (Partition Tolerance) у контексті CAP-теореми означає, що система продовжує працювати і відповідати 
на запити навіть у разі мережевих поділів або збоїв. Це означає, що система може продовжувати функціонувати, навіть якщо 
є розриви в комунікації між частинами мережі.

На практиці це означає наступне:

1. **Вузли можуть працювати автономно**:
   - Якщо мережевий зв'язок між деякими вузлами системи розривається, ці вузли все одно продовжують обслуговувати запити 
клієнтів незалежно один від одного.

2. **Реплікація даних**:
   - Для забезпечення стійкості до розділу дані копіюються на кілька вузлів. У разі розділу кожен з цих вузлів може продовжувати
працювати з локальною копією даних, поки не відновиться зв'язок.

3. **Автономне прийняття рішень**:
   - Вузли повинні мати можливість приймати локальні рішення, не залежно від стану інших вузлів у системі. 
Це забезпечує безперервність обслуговування навіть у разі розділу мережі.

4. **Синхронізація даних після відновлення зв'язку**:
   - Після відновлення мережевого зв'язку між вузлами система повинна мати механізми для синхронізації даних, 
щоб забезпечити консистентність і цілісність інформації.

Прикладом системи, що забезпечує стійкість до розділу, є розподілені бази даних, такі як Apache Cassandra або Amazon DynamoDB. 
Ці системи можуть обробляти дані навіть у разі мережевих поділів, забезпечуючи високу доступність і стійкість до збоїв.

Стійкість до розділу є важливою характеристикою для систем, що працюють у великомасштабних розподілених середовищах, 
де мережеві збої і розриви можуть виникати частіше.

*/

namespace CapTheorem
{
    internal class Program
    {
        public static void Main(string[] args)
        {
            Console.WriteLine("Start to connect the the MSSQL Server...");

            var connectionString = "Server=MYKYTACHYSTYI;Database=Growacc;User Id=developer;Password=Pass1234!;TrustServerCertificate=True;Integrated Security=True; MultipleActiveResultSets=true";

            using (var connection = new SqlConnection(connectionString))
            {
                try
                {
                    Console.WriteLine("Openning...");
                    connection.Open();
                    Console.WriteLine("Was connected!");

                    using (var transaction = connection.BeginTransaction())
                    {
                        try
                        {
                            var commandText = "INSERT INTO dbo.UserAccounts (Id, FirstName, LastName, PasswordSalt, Email, PhoneNumber, AccountConfirmed, ConfirmedAt, CreatedAt, LastUpdatedAt, Deleted, DeletedAt) VALUES (@Id, @FirstName, @LastName, @PasswordSalt, @Email, @PhoneNumber, @AccountConfirmed, @ConfirmedAt, @CreatedAt, @LastUpdatedAt, @Deleted, @DeletedAt)";
                            using (var command = new SqlCommand(commandText, connection, transaction))
                            {
                                command.Parameters.AddWithValue("@Id", Guid.NewGuid());
                                command.Parameters.AddWithValue("@FirstName", "Mykyta");
                                command.Parameters.AddWithValue("@LastName", "Chystyi");
                                command.Parameters.AddWithValue("@PasswordSalt", "Pass1234!");
                                command.Parameters.AddWithValue("@Email", "newuser@example.com");
                                command.Parameters.AddWithValue("@PhoneNumber", "+380671296328");
                                command.Parameters.AddWithValue("@AccountConfirmed", 0);
                                command.Parameters.AddWithValue("@ConfirmedAt", DateTime.UtcNow);
                                command.Parameters.AddWithValue("@CreatedAt", DateTime.UtcNow);
                                command.Parameters.AddWithValue("@LastUpdatedAt", DateTime.UtcNow);
                                command.Parameters.AddWithValue("@Deleted", 0);
                                command.Parameters.AddWithValue("@DeletedAt", DateTime.UtcNow);
                                command.ExecuteNonQuery();
                            }

                            transaction.Commit();
                            Console.WriteLine("Transaction committed.");
                        }
                        catch (Exception ex)
                        {
                            transaction.Rollback();
                            Console.WriteLine("Transaction rolled back. Error: " + ex.Message);
                        }
                    }
                }
                catch (Exception e)
                {
                    Console.WriteLine("Error: " + e.Message);
                }
            }

            Console.Read();
        }
    }
}

/*

Кластерний індекс (clustered index) і некластерний індекс (non-clustered index) — це механізми в базах 
даних для підвищення швидкості виконання запитів.

### Кластерний індекс:
Кластерний індекс зберігає дані таблиці на фізичному рівні в певному порядку. Наприклад, якщо ви створите 
кластерний індекс на стовпці "id", дані в таблиці будуть фізично впорядковані за значеннями цього стовпця. 
В таблиці може бути лише один кластерний індекс.

**Переваги:**
- Швидке виконання запитів, що шукають діапазон значень.
- Ефективніше використання дискового простору.

**Недоліки:**
- Операції вставки, оновлення та видалення можуть бути повільнішими через необхідність підтримання порядку.

### Некластерний індекс:
Некластерний індекс створює окрему структуру, яка зберігає значення індексованого стовпця і покажчики на
фізичне розташування відповідних рядків у таблиці. Некластерні індекси не змінюють фізичний порядок даних в таблиці. 
Таблиця може мати кілька некластерних індексів.

**Переваги:**
- Можливість створення декількох індексів на одній таблиці.
- Швидкий доступ до конкретних значень.

**Недоліки:**
- Більше дискового простору для зберігання індексів.
- Можливе збільшення часу вставки, оновлення та видалення даних.

Сподіваюсь, це допомогло розібратися! Якщо у вас є ще питання, дайте знати.


Кластерні та некластерні індекси застосовуються в багатьох випадках залежно від вимог до швидкості виконання запитів 
і характеру даних. Ось кілька прикладів:

### Кластерні індекси:
1. **Таблиці з частими запитами на діапазон** - наприклад, пошук за датами.
2. **Первинні ключі** - часто використовуються для уникнення дублювання і забезпечення унікальності.
3. **Великі таблиці** - для підвищення ефективності доступу до даних.

### Некластерні індекси:
1. **Таблиці з частими пошуками** - для пришвидшення пошуку за конкретними значеннями.
2. **Фільтрація даних** - для відбору рядків на основі умов.
3. **Запити з JOIN** - для поліпшення продуктивності об'єднання таблиць.

Чи є щось конкретне, що вас цікавить у використанні індексів у вашому проекті?


Основні відмінності між кластерними та некластерними індексами:
Кластерний індекс:

Фізичний порядок даних: Змінює фізичний порядок даних у таблиці відповідно до значень індексованого стовпця.

Кількість на таблицю: Лише один кластерний індекс можна створити для кожної таблиці.

Ефективність для діапазонів: Швидкий доступ до даних при запитах, що шукають діапазони значень.

Приклад: У таблиці замовлень кластерний індекс можна створити на стовпці "OrderDate", 
щоб дані були впорядковані за датою замовлення.

Некластерний індекс:

Фізичний порядок даних: Не змінює фізичний порядок даних у таблиці. 
Створює окрему структуру для індексованого стовпця.

Кількість на таблицю: Можна створити кілька некластерних індексів на одній таблиці.

Ефективність для точкових запитів: Швидкий доступ до конкретних значень або фільтрації даних.

Приклад: У таблиці замовлень некластерний індекс можна створити на стовпці "CustomerID", 
щоб швидко знаходити замовлення конкретного клієнта.

Висновки:
Використовуйте кластерні індекси, якщо вам потрібен швидкий доступ до діапазонів значень 
і якщо в таблиці є стовпець, який часто використовується для сортування.

Використовуйте некластерні індекси для запитів, що шукають конкретні значення, та для створення кількох 
індексів на різних стовпцях однієї таблиці.
 



У C# можна створювати індекси для баз даних за допомогою різних ORM (Object-Relational Mapping) бібліотек, 
таких як Entity Framework. Ось приклад, як можна створити кластерні та некластерні індекси за допомогою Entity Framework.

### Кластерний індекс:
Створення кластерного індексу зазвичай виконується на первинному ключі. Припустимо, у вас є така модель:

```csharp
public class Order
{
    public int OrderId { get; set; }
    public DateTime OrderDate { get; set; }
    public int CustomerId { get; set; }
}
```

Первинний ключ (OrderId) автоматично створює кластерний індекс у таблиці. Ось як ви можете налаштувати 
це у контексті Entity Framework:

```csharp
public class AppDbContext : DbContext
{
    public DbSet<Order> Orders { get; set; }

    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        modelBuilder.Entity<Order>()
            .HasKey(o => o.OrderId); // Це створює кластерний індекс на OrderId
    }
}
```

### Некластерний індекс:
Створення некластерного індексу виконується за допомогою анотацій даних або конфігурацій у Fluent API. 
Наприклад, створимо некластерний індекс на стовпці CustomerId:

```csharp
public class Order
{
    public int OrderId { get; set; }
    public DateTime OrderDate { get; set; }
    public int CustomerId { get; set; }
}

public class AppDbContext : DbContext
{
    public DbSet<Order> Orders { get; set; }

    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        modelBuilder.Entity<Order>()
            .HasIndex(o => o.CustomerId) // Це створює некластерний індекс на CustomerId
            .HasDatabaseName("IX_CustomerId"); // Необов'язково: Назва індексу
    }
}
```

Цей код показує, як налаштувати кластерні та некластерні індекси за допомогою Entity Framework у C#. 
Кластерний індекс автоматично створюється на первинному ключі, а некластерні індекси можна додавати 
за допомогою Fluent API або анотацій даних.

Сподіваюсь, це допомогло! Якщо маєте ще питання або потрібні додаткові приклади, дайте знати.
*/

