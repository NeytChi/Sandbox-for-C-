int[] arr = { 1, 2, 3, 4, 5 };
int result = Example.ExampleAlgorithm(arr);
Console.WriteLine("Total: " + result);


public static class Example
{
    public static int ExampleAlgorithm(int[] arr)
    {
        int n = arr.Length;
        int total = 0;

        for (int i = 0; i < n; i++)            // O(n)
        {
            for (int j = 0; j < n; j++)        // O(n)
            {
                total += arr[i];               // O(1)
            }
        }

        return total;
    }
}

/*

У цьому прикладі:

Ми маємо два вкладених цикли for, кожен з яких виконується 𝑛 разів, де 𝑛 – це довжина масиву arr.

Операції всередині вкладених циклів (додавання значення до total) виконуються за постійний час 𝑂(1).

Таким чином, загальна O-складність цього алгоритму є 𝑂(𝑛2).

Обчислення O-складності алгоритму (відомої як асимптотична складність) допомагає зрозуміти, 
як змінюється час виконання або використання пам'яті алгоритму залежно від розміру вхідних даних. 
Ось покроковий підхід, який допоможе вам визначити O-складність:

Визначте вхідні дані: Почніть з визначення вхідних даних вашого алгоритму 
(наприклад, масив, список, число тощо) та їх розміру, який зазвичай позначається як 𝑛.

Проаналізуйте кожну операцію: 
Проаналізуйте кожну операцію у вашому коді, щоб визначити, скільки часу вона займає залежно від 𝑛.

Операції, які виконуються постійний час, зазвичай мають складність 𝑂(1).
Операції, які залежать від 𝑛, мають складність 𝑂(𝑛), 𝑂(𝑛2) тощо.
Врахуйте вкладені цикли: Якщо у вашому коді є цикли, вкладені один в одного, 
це може суттєво вплинути на O-складність.



Тимчасова складність
Тимчасова складність оцінює, скільки часу потрібно алгоритму до виконання. 
Вона зазвичай виявляється у термінах O-нотації (Big O notation), яка показує, 
як час виконання алгоритму зростає зі збільшенням розміру вхідних даних.

O(1): Константна складність. Час виконання залежить від розміру вхідних даних.
O(log n): Логарифмічна складність. Час виконання зростає логарифмічно зі збільшенням розміру вхідних даних.
O(n): Лінійна складність. Час виконання зростає лінійно зі збільшенням обсягу вхідних даних.
O(n log n): Лінійно-логарифмічна складність. Час виконання зростає швидше, ніж лінійно, але повільніше, 
ніж квадратично.
O(n^2): Квадратична складність. Час виконання зростає квадратично зі збільшенням обсягу вхідних даних.
O(2^n): Експонентна складність. Час виконання зростає експонентно зі збільшенням розміру вхідних даних.
Просторова складність
Просторова складність оцінює, скільки пам'яті потрібно алгоритму до виконання. 
Вона також виявляється у термінах O-нотації.

Приклади
Пошук у відсортованому масиві:
Бінарний пошук: O(log n)
Сортування масиву:
Пухирцеве сортування: O(n^2)
Швидке сортування: O(n log n) у середньому випадку
Пошук у невідсортованому масиві:
Лінійний пошук: O(n)
Висновок
Розуміння складності алгоритмів допомагає вибирати найефективніші алгоритми 
на вирішення конкретних завдань, що особливо важливо під час роботи з великими обсягами даних. 
Якщо у вас є конкретні питання або приклади, які ви хотіли б обговорити, дайте знати!

На практиці, логарифмічна складність алгоритму (О(log n)) виникає, 
коли потрібно скоротити великий обсяг даних до менших підмасивів на кожному кроці. 
Це часто зустрічається в алгоритмах, де здійснюється пошук, сортування або побудова дерев. 
Ось кілька прикладів таких алгоритмів та методів їх реалізації:
Бінарний пошук:
    Використовується для пошуку елемента у відсортованому масиві. 
Розділяє масив на половини та шукає тільки в одній з них.
Приклад: O(log n) для пошуку елемента в масиві розміром n.
Бінарне дерево пошуку (BST):
    В основному використовується для організації даних, де пошук, вставка і видалення відбуваються за O(log n).
    Приклад: Пошук, вставка або видалення вузла в дереві розміром n.
Алгоритми сортування:
    Heapsort: Створення кучи займає O(n), а сортування O(n log n).
    Mergesort: Розділяє масив на підмасиви та об'єднує їх за O(n log n).

# Приклад бінарного пошуку
def binary_search(arr, low, high, target):
    if high >= low:
        mid = (high + low) // 2

        # Якщо елемент посередині
        if arr[mid] == target:
            return mid
        
        # Якщо елемент менший за середній, шукаємо в лівій половині
        elif arr[mid] > target:
            return binary_search(arr, low, mid - 1, target)
        
        # Якщо елемент більший за середній, шукаємо в правій половині
        else:
            return binary_search(arr, mid + 1, high, target)
    else:
        # Елемент не знайдений
        return -1

# Приклад використання
arr = [2, 3, 4, 10, 40]
target = 10
result = binary_search(arr, 0, len(arr)-1, target)

if result != -1:
    print(f"Елемент знаходиться на індексі {result}")
else:
    print("Елемент не знайдений в масиві")


*/